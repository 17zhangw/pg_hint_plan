<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>pg_hint_plan</title>
<!-- Uncoment after the tool has been hosted somewhere.
<link rel="home" title="pg_hint_plan" href="index.html">
-->
<link rel="stylesheet" type="text/css" href="style.css">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>

<body>
<h1 id="pg_hint_plan">pg_hint_plan 0.1.0</h1>
<div class="navigation">
  <a href="pg_hint_plan-ja.html">pg_hint_plan</a>
</div>
<hr>

<div class="index">
<ol>
<li><a href="#name">pg_hint_planとは？</a></li>
<li><a href="#description">機能概要</a></li>
<li><a href="#install">インストール</a>
<ol>
  <li><a href="#requirement">動作環境</a></li>
  <li><a href="#build">ビルド</a></li>
</ol>
</li>
<li><a href="#uninstall">アンインストール</a></li>
<li><a href="#usage">使い方</a>
<ol>
  <li><a href="#hint-load">pg_hint_planのロード</a></li>
  <li><a href="#hint-rule">ヒントの記述方法</a></li>
  <li><a href="#hint-group">ヒントのグループ</a></li>
  <li><a href="#hint-GUC">pg_hint_planのGUCパラメータ</a></li>
</ol>
</li>
<li><a href="#restrictions">使用上の注意と制約</a></li>
<li><a href="#known-issues">既知の問題</a></li>
<li><a href="#seealso">関連項目</a></li>
<li><a href="hint_list-ja.html">Appendix A. ヒント一覧</a></li>
</div>

<h2 id="name">pg_hint_planとは？</h2>
<p>pg_hint_planは、元のSQL文を変えずに実行計画を制御するためのツールです。</p>

<h2 id="description">機能概要</h2>
<p>pg_hint_planを用いると、ヒントを記述したブロックコメントをSQL文の前に加えることで、実行計画を制御することができます。</p>

<h2 id="install">インストール</h2>
<p>pg_hint_planのインストール方法について説明します。</p>

<h3 id="requirement">動作環境</h3>
<dl>
<dt>PostgreSQL</dt>
  <dd>バージョン 9.1.3</dd>
  <dd>バージョン 9.2devel 4月2日版</dd>
<dt>動作検証済みOS</dt><dd>RHEL 6.1</dd>
</dl>

<h3 id="build">ビルド</h3>
<p>pg_hint_planをソースコードからビルドする場合、pg_hint_planのソースを展開したディレクトリでmake → make installの順に実行してください。なお、pg_hint_planのビルドにはpgxsを使用するので、RPM版のPostgreSQLを使用している環境では、postgresql-devel パッケージが必要です。</p>
<p>以下にビルドの例を示します。</p>
<pre>
$ tar xzvf pg_hint_plan-0.1.0.tar.gz
$ cd pg_hint_plan-0.1.0
$ make
$ make install
</pre>

<h2 id="uninstall">アンインストール</h2>
<p>pg_hint_planをアンインストールするには、pg_hint_planのソースを展開したディレクトリでmake uninstallを実行してください。</p>
<p>以下にアンインストールの例を示します。</p>
<pre>
$ cd pg_hint_plan-0.1.0
$ make uninstall
</pre>

<h2 id="usage">使い方</h2>
<p>pg_hint_planの使い方について説明します。</p>

<h3 id="hint-load">pg_hint_planのロード</h3>
<p>pg_hint_planを使うには、以下の例のようにpg_hint_planの共有ライブラリをロードしてください。全てのセッションでpg_hint_planを有効にするには、shared_preload_librariesに'pg_hint_plan'を追加して下さい。</p>
<pre>
postgres=# LOAD 'pg_hint_plan';
LOAD
postgres=# </pre>

<h3 id="hint-rule">ヒントの記述方法</h3>
<p>ヒントはクエリの前のブロックコメント内に、スペース、タブまたは改行のいずれかで区切って記述してください。ヒントの対象がテーブルの場合は、テーブル名または別名(エイリアス)で指定してください。ただし、スキーマが異なる同じ名前のテーブルを1クエリ中に用いる場合は、別名で指定してください。これは、クエリ中の特定のテーブルを指定できるようにするためです。</p>

<p>以下の例では、HashJoinとSeqScanヒントにより、pgbench_accountsテーブルに対するSeq Scanの結果をHash Joinする実行計画が選択されています。</p>
<pre>
postgres=# /*
postgres*#    <span class="strong">HashJoin(a b)</span>
postgres*#    <span class="strong">SeqScan(a)</span>
postgres*#  */
postgres-# EXPLAIN SELECT *
postgres-#    FROM pgbench_branches b
postgres-#    JOIN pgbench_accounts a ON b.bid = a.bid
postgres-#   ORDER BY a.aid;
                                      QUERY PLAN
---------------------------------------------------------------------------------------
 Sort  (cost=31465.84..31715.84 rows=100000 width=197)
   Sort Key: a.aid
   ->  <span class="strong">Hash Join</span>  (cost=1.02..4016.02 rows=100000 width=197)
         Hash Cond: (a.bid = b.bid)
         ->  <span class="strong">Seq Scan on pgbench_accounts a</span>  (cost=0.00..2640.00 rows=100000 width=97)
         ->  Hash  (cost=1.01..1.01 rows=1 width=100)
               ->  Seq Scan on pgbench_branches b  (cost=0.00..1.01 rows=1 width=100)
(7 rows)

postgres=# </pre>

<h3 id="hint-group">ヒントのグループ</h3>
<p>pg_hint_planで使えるヒントのグループは、スキャン方式と結合方式、結合順序、GUCパラメータの4通りに分けられます。同じグループのヒントを同じオブジェクトに対して指定した場合は、最後に指定したヒントが適用されます。各グループの具体的なヒントは、<a href="hint_list-ja.html">ヒント一覧</a>を参照してください。</p>

<h4>スキャン方式</h4>
<p>テーブルに対して、どんなスキャンを選択するか指定できるヒントのグループのことです。
特定のテーブルに対するスキャン方式を選択したい場合は、そのスキャン方式のヒントと、対象となるオブジェクトの名前を指定してください。
特定のテーブルに対するスキャン方式を選択してほしくない場合は、そのスキャン方式のヒントの先頭に No を記述した上で、対象となるオブジェクトの名前を指定してください。</p>
<p>以下に示した具体例について説明します。</br>
1つ目のSQL文では、aテーブルにIndex Scanを選択させるヒントを用いたため、実行計画作成時にaテーブルに対してIndex Scanを選択しています。</br>
2つ目のSQL文では、aテーブルにIndex Scan以外を選択させるヒントを用いたため、実行計画作成時にaテーブルに対してIndex Scan以外のスキャン方式であるSeq Scanを選択しています。</p>
<pre>postgres=# /* <span class="strong">IndexScan(a)</span> */
postgres-# EXPLAIN SELECT *
postgres-#    FROM pgbench_accounts a
postgres-#   ORDER BY aid;
                                               QUERY PLAN
---------------------------------------------------------------------------------------------------------
 <span class="strong">Index Scan</span> using pgbench_accounts_pkey on pgbench_accounts a  (cost=0.00..4247.26 rows=100000 width=97)
(1 row)

postgres=# /* <span class="strong">NoIndexScan(a)</span> */
postgres-# EXPLAIN SELECT *
postgres-#    FROM pgbench_accounts a
postgres-#   ORDER BY aid;
                                   QUERY PLAN
---------------------------------------------------------------------------------
 Sort  (cost=21885.82..22135.82 rows=100000 width=97)
   Sort Key: aid
   ->  <span class="strong">Seq Scan</span> on pgbench_accounts a  (cost=0.00..2640.00 rows=100000 width=97)
(3 rows)

postgres=#
</pre>
<h4>結合方式</h4>
<p>テーブルの結合に対して、どんな結合を選択するか指定できるヒントのグループのことです。
特定の結合方式を選択したい場合は、その結合方式のヒントと、対象となる2つ以上のオブジェクトの名前を指定してください。
特定の結合方式を選択してほしくない場合は、その結合方式のヒントの先頭に No を記述した上で、対象となるオブジェクトの名前を指定してください。</p>
<p>以下に示した具体例について説明します。</br>
1つ目のSQL文では、aテーブルとbテーブルの結合にMerge Joinを選択させるヒントを用いたため、実行計画作成時にMerge Joinを選択しています。</br>
2つ目のSQL文では、aテーブルとbテーブルの結合にMerge Join以外を選択させるヒントを用いたため、実行計画作成時にMerge Join以外の結合方式であるNested Loopを選択しています。</p>
<pre>
postgres=# /*
postgres*#   <span class="strong">MergeJoin(b a)</span>
postgres*#  */
postgres-# EXPLAIN SELECT *
postgres-#    FROM pgbench_branches b
postgres-#    JOIN pgbench_accounts a ON b.bid = a.bid;
                                         QUERY PLAN
---------------------------------------------------------------------------------------------
 <span class="strong">Merge Join</span>  (cost=21886.84..23636.85 rows=100000 width=197)
   Merge Cond: (b.bid = a.bid)
   ->  Sort  (cost=1.02..1.02 rows=1 width=100)
         Sort Key: b.bid
         ->  Seq Scan on pgbench_branches b  (cost=0.00..1.01 rows=1 width=100)
   ->  Materialize  (cost=21885.82..22385.82 rows=100000 width=97)
         ->  Sort  (cost=21885.82..22135.82 rows=100000 width=97)
               Sort Key: a.bid
               ->  Seq Scan on pgbench_accounts a  (cost=0.00..2640.00 rows=100000 width=97)
(9 rows)

postgres=# /*
postgres*#   <span class="strong">NoMergeJoin(b a)</span>
postgres*#  */
postgres-# EXPLAIN SELECT *
postgres-#    FROM pgbench_branches b
postgres-#    JOIN pgbench_accounts a ON b.bid = a.bid;
                                   QUERY PLAN
---------------------------------------------------------------------------------
 <span class="strong">Nested Loop</span>  (cost=0.00..3891.01 rows=100000 width=197)
   Join Filter: (b.bid = a.bid)
   ->  Seq Scan on pgbench_branches b  (cost=0.00..1.01 rows=1 width=100)
   ->  Seq Scan on pgbench_accounts a  (cost=0.00..2640.00 rows=100000 width=97)
(4 rows)

postgres=#</pre>
<h3>結合順序</h3>
<p>テーブルの結合に対して、どんな順番で結合するか指定できるヒントのグループのことです。
結合の順番を指定したい場合は、結合順序のヒント(Leading)と、2つ以上のオブジェクトの名前を結合したい順番で指定してください。</p>
<p>以下に示した具体例について説明します。</br>
この例では、bテーブルとaテーブルを結合させた後、この結合テーブルとtテーブルを結合させるヒントを用いたため、実行計画作成時にヒントで指定したテーブル順でテーブル結合を選択しています。</p>
<pre>postgres=# /*
postgres*#  <span class="strong">Leading(b a t)</span>
postgres*#  */
postgres-# EXPLAIN SELECT *
postgres-#    FROM pgbench_branches b
postgres-#    JOIN pgbench_accounts a ON b.bid = a.bid
postgres-#    JOIN pgbench_tellers t ON b.bid = t.bid;
                                                  QUERY PLAN
--------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=1.23..15399.49 rows=1000000 width=297)
   <span class="strong">Hash Cond: (b.bid = t.bid)</span>
   ->  Nested Loop  (cost=0.00..3898.27 rows=100000 width=197)
         <span class="strong">Join Filter: (b.bid = a.bid)</span>
         ->  Index Scan using pgbench_branches_pkey on pgbench_branches b  (cost=0.00..8.27 rows=1 width=100)
         ->  Seq Scan on pgbench_accounts a  (cost=0.00..2640.00 rows=100000 width=97)
   ->  Hash  (cost=1.10..1.10 rows=10 width=100)
         ->  Seq Scan on pgbench_tellers t  (cost=0.00..1.10 rows=10 width=100)
(8 rows)

postgres=#</pre>
<h3>GUCパラメータ</h3>
<p>1クエリ限りでGUCパラメータを設定できるヒントのグループのことです。
1クエリ限りでGUCパラメータを設定したい場合は、GUCパラメータを設定するためのヒント(Set)と、設定したいGUCパラメータとそのパラメータの値を指定してください。ただし、指定する値に小文字とアンダースコア(_)以外の文字(大文字、数字、空白スペースなど)を含む場合はダブルクォート(")で囲んでください。</p>
<p>以下に示した具体例について説明します。</br>
1つ目のSQL文は、GUCパラメータのenable_hashjoinとenable_nestloopをoffに設定するヒントを用いたため、実行計画作成時に各テーブル間の結合でMerge Joinを選択しています。</br>
2つ目のSQL文は、GUCパラメータのjoin_collapse_limitを1に設定するヒントを用いたため、実行計画作成時にFROM句で指定したテーブル順でテーブル結合を選択しています。</p>
<pre>postgres=# /*
postgres*#   Set(enable_hashjoin off)
postgres*#   Set(enable_nestloop off)
postgres*#  */
postgres-# EXPLAIN SELECT *
postgres-#    FROM pgbench_branches b
postgres-#    JOIN pgbench_accounts a ON b.bid = a.bid
postgres-#    JOIN pgbench_tellers t ON b.bid = t.bid;
                                         QUERY PLAN
---------------------------------------------------------------------------------------------
 <span class="strong">Merge Join</span>  (cost=21888.11..37138.29 rows=1000000 width=297)
   Merge Cond: (b.bid = a.bid)
   ->  <span class="strong">Merge Join</span>  (cost=2.29..2.44 rows=10 width=200)
         Merge Cond: (b.bid = t.bid)
         ->  Sort  (cost=1.02..1.02 rows=1 width=100)
               Sort Key: b.bid
               ->  Seq Scan on pgbench_branches b  (cost=0.00..1.01 rows=1 width=100)
         ->  Sort  (cost=1.27..1.29 rows=10 width=100)
               Sort Key: t.bid
               ->  Seq Scan on pgbench_tellers t  (cost=0.00..1.10 rows=10 width=100)
   ->  Materialize  (cost=21885.82..22385.82 rows=100000 width=97)
         ->  Sort  (cost=21885.82..22135.82 rows=100000 width=97)
               Sort Key: a.bid
               ->  Seq Scan on pgbench_accounts a  (cost=0.00..2640.00 rows=100000 width=97)
(14 rows)

postgres=# /*
postgres*#   Set(join_collapse_limit "1")
postgres*#  */
postgres-# EXPLAIN SELECT *
postgres-#    FROM pgbench_branches b
postgres-#    JOIN pgbench_accounts a ON b.bid = a.bid
postgres-#    JOIN pgbench_tellers t ON b.bid = t.bid;
                                                  QUERY PLAN
--------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=1.23..15399.49 rows=1000000 width=297)
   Hash Cond: (b.bid = t.bid)
   ->  Nested Loop  (cost=0.00..3898.27 rows=100000 width=197)
         Join Filter: (b.bid = a.bid)
         ->  Index Scan using pgbench_branches_pkey on pgbench_branches b  (cost=0.00..8.27 rows=1 width=100)
         ->  Seq Scan on pgbench_accounts a  (cost=0.00..2640.00 rows=100000 width=97)
   ->  Hash  (cost=1.10..1.10 rows=10 width=100)
         ->  Seq Scan on pgbench_tellers t  (cost=0.00..1.10 rows=10 width=100)
(8 rows)

postgres=#</pre>

<h3 id="hint-GUC">pg_hint_planのGUCパラメータ</h3>
<p>pg_hint_planツールに関するGUCパラメータを以下に記述します。</p>
<table>
<thead>
<tr>
<tr><th>GUCパラメータ</th><th>説明</th><th>デフォルト値</th></tr>
</tr></thead>
<tbody>
<tr><td>pg_hint_plan.enable</td>
  <td>on のとき、pg_hint_planの機能を有効にします。</td><td>on</td></tr>
<tr><td>pg_hint_plan.debug_print</td>
  <td>on のとき、プランナが実行計画を生成するときに用いたヒントを表示します。</td><td>off</td></tr>
<tr><td>pg_hint_plan.parse_message</td>
  <td>指定したヒントに対して、どのメッセージ階層を表示するかを指定します。有効な値は、debug5、debug4、debug3、debug2、debug1、log、info、notice、warningまたはerrorです。</td><td>info</td></tr>
</tbody>
</table>

<h2 id="restrictions">使用上の注意と制約</h2>
<p>pg_hint_planを使用する際には、以下の注意と制約があります。</p>
<dl>
<dt>ヒントの記述位置</dt>
<dd>クエリの前に複数のブロックコメントを記述する場合は、最初のブロックコメントにのみヒントを記述してください。二番目以降のブロックコメントは、ヒントと見なされず無視されます。以下の例では、HashJoin(a b)とSeqScan(a)がヒントと見なされ、IndexScan(a)とMergeJoin(a b)は無視されています。</p>
<pre>
postgres=# /*
postgres*#    <span class="strong">HashJoin(a b)</span>
postgres*#    <span class="strong">SeqScan(a)</span>
postgres*#  */
postgres-# /* IndexScan(a) */
postgres-# EXPLAIN SELECT /* MergeJoin(a b) */ *
postgres-#    FROM pgbench_branches b
postgres-#    JOIN pgbench_accounts a ON b.bid = a.bid
postgres-#   ORDER BY a.aid;
                                      QUERY PLAN
---------------------------------------------------------------------------------------
 Sort  (cost=31465.84..31715.84 rows=100000 width=197)
   Sort Key: a.aid
   ->  <span class="strong">Hash Join</span>  (cost=1.02..4016.02 rows=100000 width=197)
         Hash Cond: (a.bid = b.bid)
         ->  <span class="strong">Seq Scan on pgbench_accounts a</span>  (cost=0.00..2640.00 rows=100000 width=97)
         ->  Hash  (cost=1.01..1.01 rows=1 width=100)
               ->  Seq Scan on pgbench_branches b  (cost=0.00..1.01 rows=1 width=100)
(7 rows)

postgres=# </pre>
</dd>
<dt>オブジェクト名の指定方法</dt>
<dd><p>ヒント対象のオブジェクト名に小文字とアンダースコア(_)以外の文字(大文字、数字、空白スペースなど)を含む場合は、ダブルクォート(")で囲んでください。</p><p>また、クエリ中に同一名称のテーブルが複数回出現する場合(スキーマ違いや同一テーブルの複数回使用など)は、テーブルに別名をつけてそれぞれのテーブルを区別してください。以下の例の1つ目のSQL文では、MergeJoin(t1 t1)をヒントに指定したとき、ヒント対象のオブジェクトが特定できずにエラーになっています。2つ目のSQL文では、各テーブルにptやstという別名をつけているため、実行計画作成時にヒントで指定した通りにMerge Joinを選択しています。
</p>
<pre>
postgres=# /* <span class="strong">MergeJoin(t1 t1)</span>*/
postgres-# EXPLAIN SELECT * FROM s1.t1
postgres-# JOIN public.t1 ON (s1.t1.id=public.t1.id);
INFO:  hint syntax error at or near "t1 t1)"
<span class="strong">DETAIL:  relation name "t1" is ambiguous</span>
INFO:  hint syntax error at or near "t1 t1)"
<span class="strong">DETAIL:  relation name "t1" is ambiguous</span>
                             QUERY PLAN
--------------------------------------------------------------------
 Hash Join  (cost=270.00..323.05 rows=1230 width=44)
   Hash Cond: (s1.t1.id = public.t1.id)
   ->  Seq Scan on t1  (cost=0.00..22.30 rows=1230 width=36)
   ->  Hash  (cost=145.00..145.00 rows=10000 width=8)
         ->  Seq Scan on t1  (cost=0.00..145.00 rows=10000 width=8)
(5 rows)

postgres=# /* <span class="strong">MergeJoin(pt st)</span> */
postgres-# EXPLAIN SELECT * FROM s1.t1 st
postgres-# JOIN public.t1 pt ON (st.id=pt.id);
                                    QUERY PLAN
----------------------------------------------------------------------------------
 <span class="strong">Merge Join</span>  (cost=0.00..421.33 rows=1230 width=44)
   Merge Cond: (st.id = pt.id)
   ->  Index Scan using t1_id_idx on t1 st  (cost=0.00..62.70 rows=1230 width=36)
   ->  Index Scan using t1_pkey on t1 pt  (cost=0.00..318.25 rows=10000 width=8)(4 rows)

postgres=#</pre>
</p>
</dd>
<dt>ヒントの記述誤り</dt>
<dd>pg_hint_planでは、ヒントの記述に誤りがあった場合は、誤った記述に関する情報を出力しますがエラー終了しません。誤った記述より前のヒントのみ有効となり、誤った記述以降のヒントを無視してクエリを実行します。</dd>
<dt>指定するヒントの種類の重複</dt>
<dd>同じオブジェクトに対して同じグループのヒントを重複して指定した場合は、最後に指定したヒントを使用します。</dd>
<dt>ビューに対する制限</dt>
<dd>ビューを複数用いるときに、各ビュー内のテーブルの別名が重複した場合は、ヒントの対象を区別できません。区別する場合は、各ビュー内のテーブルの別名を重複させないでください。</dd>
</dl>

<h2 id="known-issues">既知の問題</h2>
<p>pg_hint_planに関する既知の問題について説明します。</p>
<dl>
<dt>副問い合わせを含むSELECT文</dt>
<dd id="view_limit">pg_hint_planの使用中に副問い合わせを含むSELECT文を実行すると、サーバ側で異常終了する場合があります。よって、pg_hint_planを試用しているときは、副問い合わせを含むSELECT文を実行しないでください。</dd>
</dl>

<h2 id="seealso">関連項目</h2>
<h3 id="postgresql_document">PostgreSQLドキュメント</h3>
<a href="http://www.postgresql.org/docs/9.1/static/sql-explain.html">EXPLAIN</a>
<hr>

<div class="navigation">
  <a href="pg_hint_plan-ja.html">pg_hint_plan</a>
</div>

<p class="footer">Copyright (c) 2012, NIPPON TELEGRAPH AND TELEPHONE CORPORATION</p>

<!--
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script><script src="pg_statsinfo-ja_files/ga.js" type="text/javascript"></script>
<script type="text/javascript">
try{
var pageTracker = _gat._getTracker("UA-10244036-6");
pageTracker._trackPageview();
} catch(err) {}
</script>
-->
</body>
</html>
